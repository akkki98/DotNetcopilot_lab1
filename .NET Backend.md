# **Lab: Building a .NET Backend API with GitHub Copilot**

## **Lab Scenario**

You are working as a backend developer for **QuickKart**, an online retail platform.  
Your task is to build a **Product Management API** using **ASP.NET Core Web API**.

You will use **GitHub Copilot** to accelerate development in these backend areas:

- Generate REST API endpoints  
- Implement database operations using EF Core  
- Add structured error handling and logging  
- Write unit tests using xUnit and Moq  

The final output will be a fully working .NET Web API with:

‚úî `ProductsController`  
‚úî EF Core `AppDbContext` and repository pattern  
‚úî Error handling middleware  
‚úî Automated unit tests  

---

## **Prerequisites**

- .NET 8 SDK  
- Visual Studio / VS Code  
- SQL Server LocalDB or SQLite  
- GitHub Copilot enabled  

---

## **Lab Objectives**

By the end of this lab, you will:

‚úî Build API endpoints using Copilot prompts  
‚úî Scaffold EF Core models, DbContext, and repository  
‚úî Add centralized error handling and logs  
‚úî Write unit tests with Copilot assistance  

---

# **Lab Part 1 ‚Äî Create the .NET Web API Project**

## **Step 1: Create the API project**

```bash
dotnet new webapi -o QuickKart.API
cd QuickKart.API
Step 2: Install EF Core packages
bash
Copy code
dotnet add package Microsoft.EntityFrameworkCore
dotnet add package Microsoft.EntityFrameworkCore.Sqlite
dotnet add package Microsoft.EntityFrameworkCore.Tools
Lab Part 2 ‚Äî Generate API Endpoints Using Copilot
Task
Create a new controller ProductsController with CRUD endpoints.

Prompt to Copilot
‚ÄúGenerate a ProductsController with CRUD endpoints for Product model using ASP.NET Core Web API.‚Äù

Expected Copilot Output (Example)
csharp
Copy code
[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly IProductRepository _repo;

    public ProductsController(IProductRepository repo)
    {
        _repo = repo;
    }

    [HttpGet]
    public async Task<IActionResult> GetAll() =>
        Ok(await _repo.GetAllAsync());

    [HttpGet("{id}")]
    public async Task<IActionResult> Get(int id)
    {
        var product = await _repo.GetAsync(id);
        if (product == null) return NotFound();
        return Ok(product);
    }

    [HttpPost]
    public async Task<IActionResult> Create(Product product)
    {
        await _repo.AddAsync(product);
        return CreatedAtAction(nameof(Get), new { id = product.Id }, product);
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> Update(int id, Product product)
    {
        if (id != product.Id) return BadRequest();
        await _repo.UpdateAsync(product);
        return NoContent();
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> Delete(int id)
    {
        await _repo.DeleteAsync(id);
        return NoContent();
    }
}
Lab Part 3 ‚Äî Database Operations Using Copilot
Task
Use EF Core with SQLite. Create:

Product model

AppDbContext

Repository pattern (interface + implementation)

Prompt: Product Model
‚ÄúGenerate a Product entity with Id, Name, Price, Stock properties.‚Äù

Prompt: DbContext
‚ÄúCreate an EF Core DbContext named AppDbContext with Products DbSet.‚Äù

Prompt: Repository
‚ÄúCreate IProductRepository and ProductRepository implementing CRUD using EF Core.‚Äù

Sample Copilot Output (Interface)
csharp
Copy code
public interface IProductRepository
{
    Task<List<Product>> GetAllAsync();
    Task<Product?> GetAsync(int id);
    Task AddAsync(Product product);
    Task UpdateAsync(Product product);
    Task DeleteAsync(int id);
}
Lab Part 4 ‚Äî Add Error Handling & Logging Using Copilot
Task
Add global error handling middleware.

Prompt
‚ÄúGenerate ASP.NET Core middleware for global exception handling with logging using ILogger.‚Äù

Expected Copilot Output
csharp
Copy code
public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ErrorHandlingMiddleware> _logger;

    public ErrorHandlingMiddleware(RequestDelegate next, ILogger<ErrorHandlingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task Invoke(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled exception");
            context.Response.StatusCode = 500;
            await context.Response.WriteAsJsonAsync(new { message = "An error occurred" });
        }
    }
}
Enable middleware in Program.cs:
csharp
Copy code
app.UseMiddleware<ErrorHandlingMiddleware>();
Lab Part 5 ‚Äî Unit Testing with Copilot
Task
Write unit tests for the ProductsController using xUnit + Moq.

Create test project
bash
Copy code
dotnet new xunit -o QuickKart.Tests
dotnet add QuickKart.Tests package Moq
dotnet add QuickKart.Tests reference QuickKart.API
Prompt to Copilot
‚ÄúGenerate unit tests for ProductsController using xUnit and Moq.‚Äù

Expected Copilot Output
csharp
Copy code
public class ProductsControllerTests
{
    private readonly Mock<IProductRepository> _mockRepo;
    private readonly ProductsController _controller;

    public ProductsControllerTests()
    {
        _mockRepo = new Mock<IProductRepository>();
        _controller = new ProductsController(_mockRepo.Object);
    }

    [Fact]
    public async Task Get_ReturnsNotFound_WhenNotExists()
    {
        _mockRepo.Setup(r => r.GetAsync(1)).ReturnsAsync((Product?)null);

        var result = await _controller.Get(1);

        Assert.IsType<NotFoundResult>(result);
    }

    [Fact]
    public async Task Create_ReturnsCreatedResult()
    {
        var product = new Product 
        { 
            Id = 1, 
            Name = "Test", 
            Price = 10, 
            Stock = 5 
        };

        var result = await _controller.Create(product);

        Assert.IsType<CreatedAtActionResult>(result);
    }
}
üéâ Lab Completed
You have successfully created:

‚úî A .NET Web API
‚úî EF Core repository
‚úî CRUD endpoints
‚úî Global error handler
‚úî Unit testing framework

Using GitHub Copilot to accelerate development throughout the backend pipeline.
